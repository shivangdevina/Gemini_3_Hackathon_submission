# -*- coding: utf-8 -*-
"""Another copy of todo's.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p3cNsw86TdsHl1xweNmjIJH0hToCvixd
"""



from typing import TypedDict, List,Dict
from langgraph.graph import StateGraph, END
from langchain_core.prompts import ChatPromptTemplate
from langchain_google_genai import ChatGoogleGenerativeAI
import re
import json

import os
from dotenv import load_dotenv, find_dotenv

_ = load_dotenv(find_dotenv())
llm = ChatGoogleGenerativeAI(
    model="gemini-2.5-flash",
    temperature=0
)

class Role(TypedDict):
    title: str
    weight: float

class Person(TypedDict):
    name: str
    role: Dict[str, float]
    skills: List[str]

# -----------------------------
# 1. Define State Schema
# -----------------------------
class PRDState(TypedDict):
    prd_text: str
    extracted_requirements: str
    task_breakdown: str
    verified_tasks: str
    team_members: List[Person]
    assigned_tasks: str

# -----------------------------
# 2. Prompt Templates
# -----------------------------

EXTRACT_REQUIREMENTS_PROMPT = ChatPromptTemplate.from_template("""
You are a senior product architect and technical program manager.

You are given a **very detailed Product Requirement Document (PRD)**.

Your task:
- Extract **EVERY SINGLE requirement** from the PRD.
- Do NOT summarize.
- Do NOT skip details.
- Do NOT infer missing requirements.
- Preserve original intent and constraints.

Categorize requirements strictly into:
1. Functional Requirements
2. Non-Functional Requirements
3. User Flows
4. Edge Cases
5. Dependencies
6. Constraints & Assumptions
7. Success Metrics
8. Out-of-Scope Items (if mentioned)

PRD:
{prd_text}

Return in structured bullet points with clear headings.
""")

TASK_BREAKDOWN_PROMPT = ChatPromptTemplate.from_template("""
You are a Principal Engineer responsible for converting a PRD into
ENGINEERING WORK PACKAGES (not feature checklists).

CRITICAL RULES (VIOLATION IS NOT ALLOWED):

1. ❌ DO NOT create tasks for individual operations, features, or variants
   (e.g., addition, subtraction, sin, cos, buttons, fields).
2. ❌ DO NOT create 1:1 mappings between requirements and tasks.
3. ❌ DO NOT repeat similar tasks with minor variations.
4. ✅ ALWAYS group logically related requirements into a SINGLE capability.
5. ✅ Each task must represent a meaningful engineering deliverable
   that could be owned by a team over multiple days.

DECOMPOSITION STRATEGY:
- Identify clusters of related requirements
- Convert each cluster into ONE system-level responsibility
- Ensure the task description explicitly states the scope it covers

GOOD EXAMPLES:
✔ "Implement core arithmetic computation capability supporting all basic operators"
✔ "Design and implement scientific computation support layer"
✔ "Develop unified error handling framework for invalid expressions"

BAD EXAMPLES (DO NOT PRODUCE):
✘ "Implement addition"
✘ "Implement subtraction"
✘ "Add sin button"
✘ "Handle division by zero separately from computation logic"

CATEGORIES TO USE:
1. Product & UX Responsibilities
2. Frontend Engineering Capabilities
3. Core Computation & Business Logic
4. State Management & Data Handling
5. Error Handling & Reliability
6. Performance & Non-Functional Work
7. Testing & Quality Assurance
8. Security & Privacy
9. Deployment & Platform Readiness
10. Documentation & Knowledge Transfer

Extracted Requirements:
{extracted_requirements}

Return a structured TODO list.
Each TODO must clearly state:
- What system capability is being delivered
- Which requirement cluster it satisfies
""")


VERIFY_COMPLETENESS_PROMPT = ChatPromptTemplate.from_template("""
You are performing a senior-level planning audit.

Your task:
- Identify and REMOVE low-level decomposition patterns
- Merge tasks that are variations of the same capability
- Rewrite tasks that mention:
  - Individual operations
  - UI components
  - Feature-by-feature logic

Rules:
- ❌ No per-operator tasks
- ❌ No per-feature tasks
- ✅ Tasks must represent system capabilities

Extracted Requirements:
{extracted_requirements}

Generated TODOs:
{task_breakdown}

Return the FINAL, CLEAN, HIGH-LEVEL TODO list.
""")


# -----------------------------
# 3. Graph Nodes
# -----------------------------

def extract_requirements(state: PRDState):
    response = llm.invoke(
        EXTRACT_REQUIREMENTS_PROMPT.format(
            prd_text=state["prd_text"]
        )
    )
    return {"extracted_requirements": response.content}


def generate_tasks(state: PRDState):
    response = llm.invoke(
        TASK_BREAKDOWN_PROMPT.format(
            extracted_requirements=state["extracted_requirements"]
        )
    )
    return {"task_breakdown": response.content}


def verify_tasks(state: PRDState):
    response = llm.invoke(
        VERIFY_COMPLETENESS_PROMPT.format(
            extracted_requirements=state["extracted_requirements"],
            task_breakdown=state["task_breakdown"]
        )
    )
    return {"verified_tasks": response.content}


# -----------------------------
# 4. Build LangGraph
# -----------------------------

graph = StateGraph(PRDState)

graph.add_node("extract_requirements", extract_requirements)
graph.add_node("generate_tasks", generate_tasks)
graph.add_node("verify_tasks", verify_tasks)

graph.set_entry_point("extract_requirements")
graph.add_edge("extract_requirements", "generate_tasks")
graph.add_edge("generate_tasks", "verify_tasks")
graph.add_edge("verify_tasks", END)

prd_to_todo_graph = graph.compile()

# -----------------------------
# 5. Run Example
# -----------------------------

ASSIGN_TASKS_PROMPT = ChatPromptTemplate.from_template("""
You are a senior engineering manager responsible for task allocation.

You are given:
1. A FINAL verified list of engineering TODOs.
2. A JSON list of team members.

The team member structure is:

Person:
- name: string
- role: dictionary where key = role name, value = expertise weight (0–1)
- skills: list of skills

Your job:
- Assign EACH TODO to ONE most suitable person.
- Match tasks with the closest skill alignment.
- Prefer balanced workload when multiple people qualify.
- Use role weights to prefer primary responsibilities.
- DO NOT create new tasks.
- DO NOT modify task descriptions.
- DO NOT invent new people or skills.

Return in the following structure:

Task: <task description>
Assigned To: <person name>
Reason: <short justification>

Verified TODOs:
{verified_tasks}

Team Members (JSON):
{team_members}
""")


def assign_tasks(state: PRDState):

    response = llm.invoke(
        ASSIGN_TASKS_PROMPT.format(
            verified_tasks=state["verified_tasks"],
            team_members=json.dumps(state["team_members"], indent=2)
        )
    )

    return {"assigned_tasks": response.content}

graph = StateGraph(PRDState)

graph.add_node("extract_requirements", extract_requirements)
graph.add_node("generate_tasks", generate_tasks)
graph.add_node("verify_tasks", verify_tasks)
graph.add_node("assign_tasks", assign_tasks)

graph.set_entry_point("extract_requirements")
graph.add_edge("extract_requirements", "generate_tasks")
graph.add_edge("generate_tasks", "verify_tasks")
graph.add_edge("verify_tasks", "assign_tasks")
graph.add_edge("assign_tasks", END)

prd_to_todo_graph = graph.compile()

def markdown_to_json(text):
    pattern = r"""Task:\s*(.*?)\nAssigned To:\s*(.*?)\nReason:\s*(.*?)(?=\nTask:|\Z)"""

    matches = re.findall(pattern, text, re.DOTALL)

    tasks = []
    for task, person, reason in matches:
        tasks.append({
            "task": task.strip(),
            "assigned_to": person.strip(),
            "reason": reason.strip()
        })

    return {"tasks": tasks}


#

# print(json.dumps(result, indent=2))

prd_text = """# Product Requirement Document (PRD)

## Product Name

Web-Based Calculator

## Document Version

v1.0

## Date

6 February 2026

---

## 1. Product Overview

The Web-Based Calculator is a simple, responsive calculator application that allows users to perform basic arithmetic operations directly in a web browser. The product is designed for quick calculations without requiring installation or login. The focus is on simplicity, speed, and usability across desktop and mobile devices.

---

## 2. Problem Statement

Users often need quick access to a calculator while browsing or working online. Existing solutions may require opening separate applications or include unnecessary advanced features that complicate usage. A lightweight, easy-to-use calculator website solves this problem by providing instant access to essential calculations.

---

## 3. Objectives & Goals

### Primary Goals

* Provide a fast and reliable calculator accessible from any browser
* Enable users to perform basic arithmetic operations easily
* Ensure responsive design for mobile and desktop users

### Secondary Goals

* Maintain minimal loading time
* Provide clean and intuitive user interface

---

## 4. Target Users

* Students performing daily calculations
* Professionals needing quick computations
* General internet users

---

## 5. User Stories

1. As a user, I want to enter numbers using buttons or keyboard input so that I can perform calculations quickly.
2. As a user, I want to see results instantly after pressing the equals button.
3. As a user, I want to clear inputs easily to start a new calculation.

---

## 6. Features

### Core Features

* Addition, subtraction, multiplication, and division
* Decimal number support
* Clear (C) and all clear (AC) functions
* Display screen for inputs and results
* Keyboard input support

### Future Features

* Scientific calculator mode
* Calculation history
* Dark mode toggle

---

## 7. Functional Requirements

| ID  | Requirement                           | Priority |
| --- | ------------------------------------- | -------- |
| FR1 | User can input numbers (0–9)          | High     |
| FR2 | User can select arithmetic operations | High     |
| FR3 | System calculates result on "=" input | High     |
| FR4 | User can clear current input          | High     |
| FR5 | System handles decimal operations     | Medium   |

---

## 8. Non-Functional Requirements

* Page load time under 2 seconds
* Responsive layout for different screen sizes
* Accurate calculation results
* Compatible with major browsers (Chrome, Safari, Firefox, Edge)

---

## 9. Success Metrics

* Number of successful calculations per session
* Page load speed
* User session duration
* Error-free calculation rate

---

## 10. Assumptions & Constraints

### Assumptions

* Users require only basic arithmetic operations in initial version.
* Internet connection is available.

### Constraints

* No user authentication in version 1.
* Limited to client-side calculations.

---

## 11. Risks

* Incorrect calculation due to input parsing errors
* Poor usability on small screens if not properly optimized

---

## 12. Future Enhancements

* Scientific functions (sin, cos, log)
* Calculation history storage
* Offline support using browser cache
* Theme customization

---
"""

team_members = team = [
        {
            "name": "Amannnn",
            "role": {"ML Engineer": 0.9, "Research Scientist": 0.7},
            "skills": ["python", "machine learning", "computer vision", "data preprocessing"]
        },
        {
            "name": "Riyaaaa",
            "role": {"Frontend Developer": 0.95, "UI Designer": 0.8},
            "skills": ["react", "ui/ux", "accessibility", "responsive design"]
        },
        {
            "name": "Kunallll",
            "role": {"Backend Engineer": 0.85, "System Architect": 0.7},
            "skills": ["api development", "database design", "python"]
        },
        {
            "name": "Snehaaaa",
            "role": {"Product Manager": 0.9, "Agriculture Specialist": 0.85},
            "skills": ["user research", "problem analysis", "market validation"]
        },
        {
            "name": "Arjunnnn",
            "role": {"DevOps Engineer": 0.85, "Hardware Specialist": 0.8},
            "skills": ["cloud deployment", "edge devices", "scalability"]
        }
    ]

def final_call_todo(prd_text, team_members):

    result = prd_to_todo_graph.invoke({
    "prd_text": prd_text,
    "team_members": team_members,
    "extracted_requirements": "",
    "task_breakdown": "",
    "verified_tasks": "",
    "assigned_tasks": ""
    })

    raw_text = result['assigned_tasks']
    return markdown_to_json(result["assigned_tasks"])

# results = final_call_todo(prd_text,team_members)

# results["tasks"]

# result['tasks'].sort(key=lambda x: x["assigned_to"])

